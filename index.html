<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Piano Tiles Ultimate ‚Äî Mat√≠as</title>
<style>
  :root {
    --bg-gradient: linear-gradient(120deg,#071127,#0b2140,#1a2a6c);
    --tile-base: #42E695;
    --tile-hit: #FF3CAC;
    --hud-bg: rgba(255,255,255,0.05);
    --hud-text: #cfeff7;
  }
  body {
    margin:0;
    font-family: Arial, sans-serif;
    background: var(--bg-gradient);
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    color:#fff;
  }
  #gameContainer {
    position: relative;
    width: 400px;
  }
  canvas {
  border-radius: 12px;
  display: block;
  width: 100%;
  height: 600px;
  background: linear-gradient(180deg,#0a0f1a,#07102a);
  border: 6px solid #8A2BE2; /* Borde morado llamativo alrededor del juego */
  box-shadow: 0 0 20px #8A2BE2, 0 0 40px #8A2BE2; /* Efecto de resplandor */
}
  .hud {
    display:flex;
    justify-content:space-between;
    margin-top:8px;
    font-size:14px;
  }
  .hud div {
    background: var(--hud-bg);
    padding:6px 10px;
    border-radius:8px;
  }
  #controls {
    margin-top:10px;
    display:flex;
    justify-content:space-between;
  }
  button {
    padding:8px 12px;
    border-radius:8px;
    border:none;
    cursor:pointer;
    font-weight:bold;
    background: #00e676;
    color:#02241a;
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div class="hud">
    <div>Jugador: <span id="hudName">Invitado</span></div>
    <div>Puntos: <span id="hudScore">0</span></div>
    <div>Nivel: <span id="hudLvl">1</span></div>
  </div>
  <div id="controls">
    <button id="btnStart">‚ñ∂ Jugar</button>
    <button id="btnRestart">üîÑ Reiniciar</button>
  </div>
</div>

<audio id="gameSong" src="song.mp3" preload="auto"></audio>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hudScore = document.getElementById('hudScore');
const hudLvl = document.getElementById('hudLvl');
const btnStart = document.getElementById('btnStart');
const btnRestart = document.getElementById('btnRestart');
const gameSong = document.getElementById('gameSong');

const BPM = 118;
const intervalo = (60 / BPM) * 1000;
//hola mundo
let tiles = [];
let score = 0;
let level = 1;
let speed = 1;
let running = false;
const cols = 4;
const tileW = canvas.width / cols;
const tileH = 150;
//hola xD
let spawnInterval;
let speedInterval;

const keyMap = { '1':0, '2':1, '3':2, '4':3 };
const colors = ['#FF3CAC','#2B86C5','#42E695','#FFAA00','#FF1B6B','#8A2BE2','#00C2FF'];

// Crear un nuevo tile en columna aleatoria
function spawnTile() {
  const col = Math.floor(Math.random() * cols);
  tiles.push({ x: col * tileW, y: -tileH, w: tileW, h: tileH, hit: false });
}

// Tile m√°s cercano al borde inferior
function getActiveTile() {
  if (tiles.length === 0) return null;
  // Cambiado < a > para seleccionar el tile con Y m√°s grande
  return tiles.reduce((prev, curr) => prev.y < curr.y ? curr : prev);
}
// Dibujar tiles y resaltar el activo
function drawTiles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Obtener el tile m√°s cercano al borde inferior
  const activeTile = getActiveTile();

  // Dibujar todos los tiles
  tiles.forEach(t => {
    let colorIdx = Math.min(Math.floor(speed - 1), colors.length - 1);

    // Color de relleno
    let fillColor = t.hit ? '#555' : (t === activeTile ? '#FFD700' : colors[colorIdx]);
    ctx.fillStyle = fillColor;
    ctx.fillRect(t.x + 6, t.y + 6, t.w - 12, t.h - 12);

    // Borde del tile (color contrario)
    ctx.strokeStyle = t.hit ? '#AAA' : (t === activeTile ? '#333' : '#fff');
    ctx.lineWidth = 3;
    ctx.strokeRect(t.x + 6, t.y + 6, t.w - 12, t.h - 12);

    // Peque√±a franja blanca en la parte superior del tile
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(t.x + 6, t.y + 6, t.w - 12, 6);
  });

  // Dibujar n√∫meros de columna
  ctx.fillStyle = 'white';
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  for (let i = 0; i < cols; i++) {
    const centerX = i * tileW + tileW / 2;
    const posY = canvas.height - 10;
    ctx.fillText(i + 1, centerX, posY);
  }
} // <-- cierre final de drawTiles

  // Dibujar n√∫meros de columna
  ctx.fillStyle = 'white';
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  for (let i = 0; i < cols; i++) {
    const centerX = i * tileW + tileW / 2;
    const posY = canvas.height - 10;
    ctx.fillText(i + 1, centerX, posY);
  }
}
  // Dibujar n√∫meros de columna
  ctx.fillStyle = 'white';
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  for (let i = 0; i < cols; i++) {
    const centerX = i * tileW + tileW / 2;
    const posY = canvas.height - 10;
    ctx.fillText(i + 1, centerX, posY);
  }
}

// Actualizar posici√≥n de tiles
function update() {
  if (!running) return;

  for (let i = tiles.length-1; i >= 0; i--) {
    tiles[i].y += 3*speed;
    if (tiles[i].y + tiles[i].h >= canvas.height && !tiles[i].hit) {
      gameOver();
      return;
    }
  }

  drawTiles();
  hudScore.textContent = score;
  hudLvl.textContent = level;

  requestAnimationFrame(update);
}

// Manejo de clic del mouse
canvas.addEventListener('click', (e) => {
  if (!running) return;

  const activeTile = getActiveTile();
  if (!activeTile) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Verificar si el clic est√° dentro del tile activo
  if (x < activeTile.x || x > activeTile.x + activeTile.w || y < activeTile.y || y > activeTile.y + activeTile.h) {
    gameOver();
    return;
  }

  activeTile.hit = true;
  tiles.splice(tiles.indexOf(activeTile), 1);

  score += 10;
  level = 1 + Math.floor(score / 50);
});

// Manejo de teclado
document.addEventListener('keydown', (e) => {
  if (!running) return;
  const col = keyMap[e.key];
  if (col === undefined) return;

  const activeTile = getActiveTile();
  if (!activeTile) return;

  // Verificar si la columna presionada coincide con la columna del tile activo
  if (activeTile.x / tileW !== col) {
    gameOver();
    return;
  }

  activeTile.hit = true;
  tiles.splice(tiles.indexOf(activeTile), 1);

  score += 10;
  level = 1 + Math.floor(score / 50);
});


// Terminar el juego
function gameOver() {
  running = false;
  clearInterval(spawnInterval);
  clearInterval(speedInterval);
  gameSong.pause();
  alert('Game Over! Puntos: ' + score);
}

// Iniciar juego
function startGame() {
  clearInterval(spawnInterval);
  clearInterval(speedInterval);

  tiles = [];
  score = 0;
  level = 1;
  speed = 1;
  running = true;

  gameSong.currentTime = 0;
  gameSong.play();

  spawnInterval = setInterval(spawnTile, intervalo);

  speedInterval = setInterval(() => {
    if (running) {
      speed += 0.015;
      level++;
    }
  }, 5500);

  update();
}

// Botones
btnStart.addEventListener('click', startGame);
btnRestart.addEventListener('click', () => {
  running = false;
  clearInterval(spawnInterval);
  clearInterval(speedInterval);
  startGame();
});

</script>


</body>
</html>


















