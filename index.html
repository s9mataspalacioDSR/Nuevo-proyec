<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Piano Tiles Ultimate ‚Äî Mat√≠as</title>
<style>
:root {
  --bg-gradient: linear-gradient(120deg,#071127,#0b2140,#1a2a6c);
  --tile-base: #42E695;
  --tile-hit: #FF3CAC;
  --hud-bg: rgba(255,255,255,0.05);
  --hud-text: #cfeff7;
}

body {
  margin:0;
  font-family: Arial, sans-serif;
  background: var(--bg-gradient);
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  color:#fff;
  background-size: 600% 600%;
  animation: gradientShift 15s ease infinite;
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

#gameContainer {
  position: relative;
  width: 400px;
}

canvas {
  border-radius: 12px;
  display: block;
  width: 100%;
  height: 600px;
  background: linear-gradient(180deg,#0a0f1a,#07102a);
  border: 6px solid #8A2BE2;
  box-shadow: 0 0 20px #8A2BE2, 0 0 40px #8A2BE2;
  animation: glowPulse 2s infinite alternate;
  transition: box-shadow 0.3s ease;
}

/* Glow extra cuando el usuario hace click sobre el canvas */
canvas:active {
  box-shadow: 0 0 25px #FF3CAC, 0 0 50px #8A2BE2, inset 0 0 15px #FFD700;
}

/* Efecto ‚Äúhover‚Äù general */
canvas:hover {
  box-shadow: 0 0 25px #FF3CAC, 0 0 50px #8A2BE2, inset 0 0 10px #42E695;
}
@keyframes glowPulse {
  0% {
    box-shadow: 0 0 20px #8A2BE2, 0 0 40px #8A2BE2;
  }
  50% {
    box-shadow: 0 0 30px #FF3CAC, 0 0 60px #FF3CAC;
  }
  100% {
    box-shadow: 0 0 20px #8A2BE2, 0 0 40px #8A2BE2;
  }
}

.hud {
  display:flex;
  justify-content:space-between;
  margin-top:8px;
  font-size:14px;
}

.hud div {
  background: rgba(255,255,255,0.08);
  padding:8px 12px;
  border-radius:10px;
  box-shadow: 0 0 10px rgba(255,255,255,0.2);
}

#controls {
  margin-top:10px;
  display:flex;
  justify-content:space-between;
}

button {
  padding:8px 12px;
  border-radius:8px;
  border:none;
  cursor:pointer;
  font-weight:bold;
  background: linear-gradient(45deg,#00e676,#00bfa5);
  color:#02241a;
  transition: all 0.3s ease;
}

button:hover {
  background: linear-gradient(45deg,#FF3CAC,#8A2BE2);
  box-shadow: 0 0 15px #FF3CAC, 0 0 25px #8A2BE2;
  transform: scale(1.05);
}
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas" width="400" height="600"></canvas>
  <div class="hud">
    <div>Jugador: <span id="hudName">Invitado</span></div>
    <div>Puntos: <span id="hudScore">0</span></div>
    <div>Nivel: <span id="hudLvl">1</span></div>
  </div>
  <div id="controls">
    <button id="btnStart">‚ñ∂ Jugar</button>
    <button id="btnRestart">üîÑ Reiniciar</button>
  </div>
</div>

<audio id="gameSong" src="song.mp3" preload="auto"></audio>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const hudScore = document.getElementById('hudScore');
const hudLvl = document.getElementById('hudLvl');
const btnStart = document.getElementById('btnStart');
const btnRestart = document.getElementById('btnRestart');
const gameSong = document.getElementById('gameSong');

const BPM = 118;
const intervalo = (60 / BPM) * 1000;
//hola mundo
let tiles = [];
let score = 0;
let level = 1;
let speed = 1;
let running = false;
const cols = 4;
const tileW = canvas.width / cols;
const tileH = 150;
//hola xD
let spawnInterval;
let speedInterval;

const keyMap = { '1':0, '2':1, '3':2, '4':3 };
const colors = ['#FF3CAC','#2B86C5','#42E695','#FFAA00','#FF1B6B','#8A2BE2','#00C2FF'];

// Crear un nuevo tile en columna aleatoria
function spawnTile() {
  const col = Math.floor(Math.random() * cols);
  tiles.push({ x: col * tileW, y: -tileH, w: tileW, h: tileH, hit: false });
}

// Tile m√°s cercano al borde inferior
function getActiveTile() {
  if (tiles.length === 0) return null;
  // Seleccionar el tile con Y m√°s grande (m√°s cercano al borde inferior)
  return tiles.reduce((prev, curr) => prev.y > curr.y ? prev : curr);
}
// Dibujar tiles y resaltar el activo
function drawTiles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const activeTile = getActiveTile();

  tiles.forEach(t => {
    let colorIdx = Math.min(Math.floor(speed - 1), colors.length - 1);

    let fillColor = t.hit ? '#555' : (t === activeTile ? '#FFD700' : colors[colorIdx]);

    // Relleno del tile
    ctx.fillStyle = fillColor;
    ctx.fillRect(t.x + 6, t.y + 6, t.w - 12, t.h - 12);

    // Franja blanca superior
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(t.x + 6, t.y + 6, t.w - 12, 6);

    // Borde con sombra
    ctx.strokeStyle = t.hit ? '#AAA' : (t === activeTile ? '#333' : '#fff');
    ctx.lineWidth = 3;
    ctx.shadowColor = '#8A2BE2';
    ctx.shadowBlur = 10;
    ctx.strokeRect(t.x + 6, t.y + 6, t.w - 12, t.h - 12);
    ctx.shadowBlur = 0; // resetear
  });

  // Dibujar n√∫meros de columna (solo uno)
  ctx.fillStyle = 'white';
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  for (let i = 0; i < cols; i++) {
    const centerX = i * tileW + tileW / 2;
    const posY = canvas.height - 10;
    ctx.fillText(i + 1, centerX, posY);
  }
}

// Actualizar posici√≥n de tiles
function update() {
  if (!running) return;

  for (let i = tiles.length-1; i >= 0; i--) {
    tiles[i].y += 3*speed;
    if (tiles[i].y + tiles[i].h >= canvas.height && !tiles[i].hit) {
      gameOver();
      return;
    }
  }

  drawTiles();
  hudScore.textContent = score;
  hudLvl.textContent = level;

  requestAnimationFrame(update);
}

// Manejo de clic del mouse
canvas.addEventListener('click', (e) => {
  if (!running) return;

  const activeTile = getActiveTile();
  if (!activeTile) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Verificar si el clic est√° dentro del tile activo
  if (x < activeTile.x || x > activeTile.x + activeTile.w || y < activeTile.y || y > activeTile.y + activeTile.h) {
    gameOver();
    return;
  }

  activeTile.hit = true;
  tiles.splice(tiles.indexOf(activeTile), 1);

  score += 10;
  level = 1 + Math.floor(score / 50);
});

// Manejo de teclado
document.addEventListener('keydown', (e) => {
  if (!running) return;
  const col = keyMap[e.key];
  if (col === undefined) return;

  const activeTile = getActiveTile();
  if (!activeTile) return;

  // Verificar si la columna presionada coincide con la columna del tile activo
  if (activeTile.x / tileW !== col) {
    gameOver();
    return;
  }

  activeTile.hit = true;
  tiles.splice(tiles.indexOf(activeTile), 1);

  score += 10;
  level = 1 + Math.floor(score / 50);
});


// Terminar el juego
function gameOver() {
  running = false;
  clearInterval(spawnInterval);
  clearInterval(speedInterval);
  gameSong.pause();
  alert('Game Over! Puntos: ' + score);
}

// Iniciar juego
function startGame() {
  clearInterval(spawnInterval);
  clearInterval(speedInterval);

  tiles = [];
  score = 0;
  level = 1;
  speed = 1;
  running = true;

  gameSong.currentTime = 0;
  gameSong.play();

  spawnInterval = setInterval(spawnTile, intervalo);

  speedInterval = setInterval(() => {
    if (running) {
      speed += 0.015;
      level++;
    }
  }, 5500);

  update();
}

// Botones
btnStart.addEventListener('click', startGame);
btnRestart.addEventListener('click', () => {
  running = false;
  clearInterval(spawnInterval);
  clearInterval(speedInterval);
  startGame();
});

</script>


</body>
</html>





















